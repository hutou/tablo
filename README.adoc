:source-highlighter: highlight.js
:highlightjs-languages: crystal
:toc: 
:toclevels: 4 
:icons: font 
:imagesdir: docs/assets/images

== History

Tablo is a port of [Matt Harvey's
Tabulo](https://github.com/matt-harvey/tabulo) Ruby gem to the Crystal
Language.

The first version of Tablo (v0.10.1) was released on November 30, 2021,
in the context of learning the Crystal language, which explains its
relative limitations compared to Tabulo v2.7, the current version
at that time, subject of the software port.

So this version of Tablo (v1.0) is a complete rewrite of the library.

Compared to the first version, it offers extended capabilities,
sometimes at the cost of a modified syntax. It also offers new features,
such as the ability to add a Summary table, powered by user-defined
functions (such as sum, mean, etc.), the ability to process any
Enumerable data, as well as elaborate layout possibilities: grouped
columns, different types of headers (title, subtitle, footer), linked or
detached border lines, etc.

While overall, Tablo remains, in terms of its functionalities, broadly
comparable, with a few exceptions, to the Tabulo v3.0 version of Matt
Harvey, the source code, meanwhile, has been deeply redesigned.

// {empty} +

== Features

- Presents a DRY API that is column-based, not row-based, meaning header and body rows are automatically in sync
- Lets you set fixed column widths, then either wrap or truncate the overflow
- Alternatively, “pack” the table so that columns are auto-sized to their contents
- Cell alignment is configurable, but has helpful content-based defaults (numbers right, strings left)
- Tabulate any Enumerable: the underlying collection need not be an array
- Step through your table a row at a time, printing as you go, without waiting for the underlying collection to load. In other words, have a streaming interface for free.
- Add optional title, subtitle and footer to your table
- The header row can be repeated at arbitrary intervals
- Newlines within cell content are correctly handled
- Multibyte Unicode characters are correctly handled (needs the "uniwidth" library)
- Option to preserve whole words when wrapping content
- Apply colors and other styling to table content and borders, without breaking the table
- Easily transpose the table, so that rows are swapped with columns
- Choose from several border configurations, including predefined ones such as Markdown, Ascii (default), and user-defined ones.
- Adjacent columns can be capped by a group header
- A summary table can be added to apply user-defined functions to numeric values of a column

// {empty} +


== Installation

1. Add the dependency to your shard.yml:
[literal]
 dependencies:
   tablo:
     gitlab: hutou/tablo
2. Run `shards install`
3. And insert the line

[source,crystal]
----
require "tablo"
----
at the beginnning of your app.

:toc: 
:toclevels: 4 

== Tutorial

In this tutorial, we'll start with a very simple example, which we'll build on as we go along to gradually discover all the possibilities offered by the Tablo library. 

Here's a first look at how to use Tablo to lay out a simple table of integers.

[source,crystal]
----
1	require "tablo"
2	
3	table = Tablo::Table.new([1, 2, 3]) do |t|
4	    t.add_column("itself", &.itself)
5	    t.add_column(2, header: "Double") {|n| n * 2}
6	    t.add_column(:column_3, header: "String") {|n| n.even?.to_s}
7	end
8	puts table
----

or

[source,crystal]
----
1	require "tablo"
2	
3	table = Tablo::Table.new([1, 2, 3])
4	table.add_column("itself", &.itself)
5	table.add_column(2, header: "Double") {|n| n * 2}
6	table.add_column(:column_3, header: "String") {|n| n.even?.to_s}
8	puts table
----

[literal]
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
|            3 |            6 | false        |
+--------------+--------------+--------------+

A great deal of information can already be extracted from this simple example. Let's list them:

- The only parameter required to create the table is the data source (the array of integers), but to produce a result, you obviously need to add columns

- Any number of columns can be defined, each requiring an identifier and a Proc to extract the data from each row of the source, and, if necessary, modify its type and value

- The column identifier can be of type String, Integer or Symbol. By default, the column header takes the value of the identifier, unless the optional `header:` parameter is used

- Columns are the same width

- We see two types of row: header and body. 

- Number columns are aligned to the right, and text columns to the left, for both headers and body.

- Default borders use the classic `Ascii` type 

Now, let's look at borders

=== Borders

Each border type is defined by a string of exactly 16 characters, which are
then converted into 16 strings of up to 1 character each.  The definition
string can contain any character, but two of them have a special meaning:
after conversion, the uppercase E is replaced by an empty string, and the
underscore character is replaced by a space. +
_Please note that using the capital E character may cause alignment
 difficulties._

The first 9 characters define the junction or intersection of horizontal and
vertical lines.

[cols="1,5"]
|===
|Index | Description 

| 0 | Top left corner
| 1 | Top middle junction
| 2 | Top right corner
| 3 | Middle left junction
| 4 | Middle middle intersection
| 5 | Middle right junction
| 6 | Bottom left corner
| 7 | Bottom middle junction
| 8 | Bottom right corner
|===

The next three characters define vertical separators in data rows

[cols="1,5"]
|===
|Index | Description 

| 9  | Left vertical separator
| 10 | Middle vertical separator
| 11 | Right vertical separator

|===

And finally, the last four characters define the different types of horizontal
border, depending on the type of data row or types of adjacent data rows (Row
type will be the subject of the next section)

[cols="1,5"]
|===
|Index | Description 

| 12 | Title, subtitle, footer  
| 13 | Group 
| 14 | Header 
| 15 | Body 

|===

To change a table's border type, simply assign the desired definition to the
`border_type:` parameter when initializing the table.  This can be done in two
ways, either by assigning the 16-character string directly to `border_type:`,
or by assigning the name of one of the 7 predefined borders :

[Literal]
- `BorderName::Ascii`         => `pass:["+++++++++|||----"]`
- `BorderName::ReducedAscii`  => `pass:["E_EE_EE_EE_E----"]`
- `BorderName::Modern`        => `pass:["┌┬┐├┼┤└┴┘│││────"]`
- `BorderName::ReducedModern` => `pass:["E_EE_EE_EE_E────"]`
- `BorderName::Markdown`      => `pass:["___|||___|||__-_"]`
- `BorderName::Fancy`         => `pass:["╭┬╮├┼┤╰┴╯│:│─−-⋅"]`
- `BorderName::Blank`         => `pass:["EEEEEEEEEEEEEEEE"]`

So, for example, to set `border_type:` to `BorderName::ReducedAscii`, I can either :

use the predefined border name
[source,crystal]
----
3	table = Tablo::Table.new([1, 2, 3]
      border_type: Tablo::BorderName::ReducedAscii) do |t|
----

or use its definition string
[source,crystal]
----
3	table = Tablo::Table.new([1, 2, 3]
      border_type: "E_EE_EE_EE_E----") do |t|
----


[literal]
-------------- -------------- --------------
       itself         Double   String       
-------------- -------------- --------------
            1              2   false        
            2              4   true         
            3              6   false        
-------------- -------------- --------------


=== Row types

==== Header and Body
The Header and Body data row types form the basis of table formatting. Other types
can be optionally added to establish the final layout: the Group row type and
Heading row types (Title, SubTitle and Footer).

==== Group
Adjacent columns can share a common header, above the column headers
themselves. This common headers constitute a Group row type.

To create a Group row, simply define a common header after each set of
adjacent columns to be grouped.  

[source,crystal]
----
 1	require "tablo"
 2
 3	table = Tablo::Table.new([1, 2, 3]) do |t|
 4	    t.add_column("itself", &.itself)
 5	    t.add_column(2, header: "Double") {|n| n * 2}
 6	    t.add_group("Numbers")
 7	    t.add_column(:column_3, header: "String") {|n| n.even?.to_s}
 8	    t.add_group("Text")
 9	end
10	puts table
----

[literal]
+-----------------------------+--------------+
|           Numbers           |     Text     |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
|            3 |            6 | false        |
+--------------+--------------+--------------+

By default, Group headers are centered, but their alignment can be modified
globally at table initialization time with the `group_alignment:` parameter,
or locally for a given group with the `alignment:` parameter.

[source,crystal]
----
 3	table = Tablo::Table.new([1, 2, 3],
      group_alignment: Tablo::Justify::Left) do |t|
----
 
[literal]
| Numbers                     | Text         |

or 

[source,crystal]
----
 8	    t.add_group("Text", alignment: Tablo::Justify::Left)
----
 
[literal]
|           Numbers           | Text         |

Note that the group header can be empty, and that an empty group header is
automatically created if the last column group is not specified.

==== Headings

A formatted table can optionally include a title, subtitle and footer. Each of
these elements is of type FramedHeading or UnFramedHeading.

By default, when the table is initialized, `title:`, `subtitle:` and `footer:` are
of type FramedHeading and their value is `nil`, so they are not displayed.

To display a title (or subtitle or footer), simply specify it when
initializing the table.

[source,crystal]
----
 3	table = Tablo::Table.new([1, 2, 3],
      title: Tablo::FramedHeading.new("Numbers and text")) do |t|
----

[literal]
+--------------------------------------------+
|              Numbers and text              |
+-----------------------------+--------------+
|           Numbers           | Text         |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
|            3 |            6 | false        |
+--------------+--------------+--------------+

or

[source,crystal]
----
 3	table = Tablo::Table.new([1, 2, 3],
      title: Tablo::UnFramedHeading.new("Numbers and text")) do |t|
----
                        
[literal]
               Numbers and text               
+-----------------------------+--------------+
|           Numbers           | Text         |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
|            3 |            6 | false        |
+--------------+--------------+--------------+

In addition to text framing, there's another difference between FramedHeading
and UnFramedHeading. 

FramedHeading accepts 2 additional parameters (`line_breaks_before:` and
`line_breaks_after:`) which allow it to be more or less detached from the
preceding or following text by a number of line breaks.

By default, these parameters are set to 0, and the number of line breaks is
the greater of the current element's `line_breaks_after:` and the next element's
`line_breaks_before:`, if any.

[source,crystal]
----
 3  table = Tablo::Table.new([1, 2, 3],
      title: Tablo::FramedHeading.new("Numbers and text",
        line_breaks_after: 2)) do |t|
----

[literal]
----
+--------------------------------------------+
|              Numbers and text              |
+--------------------------------------------+
 
+-----------------------------+--------------+
|           Numbers           | Text         |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
|            3 |            6 | false        |
+--------------+--------------+--------------+
----

In summary, we have 6 types of data rows : 

 
[cols="1,2"]
|===
| Type | Description 

| Header  | Always displayed, unless `header_frequency:` is `nil` or
`masked_headers:` is `true`  (_see below_)
| Body    | Always displayed
| Group   | Optional
| Title   | Optional
| Subtitle| Optional
| Footer  | Optional

|===

=== Display frequency and repeated title

An important parameter in table initialization is `header_frequency:` 

- By default, it is set to 0, i.e. rows of data other than body are displayed
only once, at the beginning for titles and headers, at the end for the footer.

[source,crystal]
----
 1  require "tablo"
 2
 3  table = Tablo::Table.new([1, 2, 3],
 4    header_frequency: 0,
 5    title: Tablo::FramedHeading.new("Numbers and text", line_breaks_after: 2),
 6    subtitle: Tablo::UnFramedHeading.new("No booleans"),
 7    footer: Tablo::UnFramedHeading.new("End of page")) do |t|
 8    t.add_column("itself", &.itself)
 9    t.add_column(2, header: "Double") { |n| n * 2 }
10    t.add_group("Numbers")
11    t.add_column(:column_3, header: "String") { |n| n.even?.to_s }
12    t.add_group("Text", alignment: Tablo::Justify::Left)
13  end
14  puts table
----

[literal]
----
+--------------------------------------------+
|              Numbers and text              |
+--------------------------------------------+
 
                  No booleans                 
+-----------------------------+--------------+
|           Numbers           | Text         |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
|            3 |            6 | false        |
+--------------+--------------+--------------+
                  End of page         
----

- If set to `nil`, only body rows are displayed.

[source,crystal]
----
 4    header_frequency: nil,
----

[literal]
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
|            3 |            6 | false        |
+--------------+--------------+--------------+

- If set to `n` (positive), group or column headers are repeated every `n` rows, as
are footers, but titles and subtitles are not repeated.

[source,crystal]
----
 4    header_frequency: 2,
----

[literal]
----
+--------------------------------------------+
|              Numbers and text              |
+--------------------------------------------+
 
                  No booleans                 
+-----------------------------+--------------+
|           Numbers           | Text         |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
+--------------+--------------+--------------+
                  End of page                 
+-----------------------------+--------------+
|           Numbers           | Text         |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            3 |            6 | false        |
|              |              |              |
+--------------+--------------+--------------+
                  End of page                 
----

However, the `title_repeated:` parameter can be set to `true` to obtain title and
subtitle repetition.

[source,crystal]
----
 4    header_frequency: 2, title_repeated: true,
----

[literal]
----
+--------------------------------------------+
|              Numbers and text              |
+--------------------------------------------+
 
                  No booleans                 
+-----------------------------+--------------+
|           Numbers           | Text         |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
+--------------+--------------+--------------+
                  End of page                 
+--------------------------------------------+
|              Numbers and text              |
+--------------------------------------------+
 
                  No booleans                 
+-----------------------------+--------------+
|           Numbers           | Text         |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            3 |            6 | false        |
|              |              |              |
+--------------+--------------+--------------+
                  End of page                 
----

=== Extracting, Formatting and Styling
    
At the heart of Tablo's operation lies the Cell, a data structure containing
all the elements required for display. 

A cell, whether fed by data extracted from the source or directly from the
code, can span several lines. Even if it initially occupies a single line,
reducing the column width can result in a cell being displayed over several
lines.

You can limit the number of lines displayed by using the `header_wrap` or
`body_wrap` parameters when initializing the table (These 2 parameters are
global to the table, and cannot be set on individual columns). If the cell
content cannot be displayed due to this restriction, a special character
(tilde by default) is inserted in the right-hand padding area of the last line
of the cell (unless right padding is set to 0 for the column).

Note here the use of the `row_divider_frequency` parameter to separate body rows

[source,crystal]
----
require "tablo"

table = Tablo::Table.new(["abc", "def\nghi\njkl\nmno\npqr", "xyz"],
  header_wrap: 2,
  body_wrap: 3,
  row_divider_frequency: 1
) do |t|
  t.add_column("A\nfour\nlines\ncell", &.itself)
end
puts table
----

[literal]
----
+--------------+
| A            |
| four        ~|
+--------------+
| abc          |
+--------------+
| def          |
| ghi          |
| jkl         ~|
+--------------+
| xyz          |
+--------------+
----

In addition, to have greater control over the line break, we can use the
`wrap_mode` parameter to choose between `Rune` (~`Char`) line break and `Word`
line break when cutting a line.

To use Tablo with non-Romanic languages, it is mandatory to use the
`naqviz/uni_char_width` shard so that the width of each grapheme is correctly
managed, without impacting alignment.


To do this, you need to:

1. Add the dependency to your shard.yml:
[literal]
 dependencies:
   tablo:
     gitlab: hutou/tablo
   uniwidth:
     github: naqvis/uni_char_width
2. Run `shards install`
3. And insert the lines

[source,crystal]
----
require "tablo"
require "uniwidth"
----
at the beginnning of your app.

  
==== Extracting

The Cell `value` attribute contains the raw data.

If directly given as argument to Headings or Group, the Cell is a `TextCell`
as it is not related to source data.

If extracted from the source (body rows), the cell is of type `DataCell`, and
the corresponding column header is also a `DataCell` (as it depends on the
type of body `value` for alignment).

The `cell_data` attribute, specific to the `DataCell` type, provides access to
the cell's coordinates (`row_index` and `column_index`), as well as the
`body_value`.  This information is used to activate conditional formatting
and styling.

[source,crystal]
----
struct CellData
  getter body_value, row_index, column_index

  def initialize(@body_value : CellType, @row_index : Int32, @column_index : Int32)
  end
end
----


The type of `value` is `Tablo::CellType`, which is simply defined as an empty
module restriction type:

[source,crystal]
----
module Tablo::CellType
end
----

This module is already included in all Crystal main scalar types. To
use a (non or less used) scalar type or a user defined class or struct, it is
mandatory to include it by reopening the class or struct. 

For example, to allow a Cell value to contain an array, we could do :

[source,crystal]
----
class Array
  include Tablo::CellType
end

table = Tablo::Table.new([[1, 2], [3, 4]]) do |t|
  t.add_column("itself") { |n| n }
end
puts table
----

[literal]
----
+--------------+
| itself       |
+--------------+
| [1, 2]       |
| [3, 4]       |
+--------------+
----

==== Formatting

Formatting consists in applying a transformation to the raw data (the
`value`) to obtain a character string ready to be displayed. The simplest
transformation (which is also the one applied by default) is simply a call to the
`to_s` method.

Using a Proc `formatter` allows you to customize formatting in a variety of
ways, from using `sprintf` formatting strings for numeric values to various
`String` methods for text  and specific `Tablo::Util` methods for both.

A formatter Proc can take four forms : the first two apply equally to TextCell
and DataCell and are applied unconditionally on `value`.

The first form expects one parameter (`value`) and the second two `value` and
`width` (column width).
 
Here is an example of the first form: 

[source,crystal]
----
require "tablo"

table = Tablo::Table.new([1, 2, 3]) do |t|
  t.add_column("itself", &.itself)
  t.add_column(2, header: "Double") { |n| n * 2 }
  t.add_column(3, header: "Float",
    header_formatter: ->(value : Tablo::CellType) { value.as(String).upcase },
    body_formatter: ->(value : Tablo::CellType) {"%.3f" % value.as(Float)}) { |n| n ** 0.5 } 
end
puts table
----


[literal]
----
+--------------+--------------+--------------+
|       itself |       Double |        FLOAT |   <1>
+--------------+--------------+--------------+
|            1 |            2 |        1.000 |
|            2 |            4 |        1.414 |
|            3 |            6 |        1.732 |
+--------------+--------------+--------------+
----

<1> Note that the FLOAT column is aligned to the right, as its alignment is
governed by the type of `value`, which is a float.


If the formatting were done directly at the data extraction level, `value` would
be of type `String` and column would be aligned to the left. 

[source,crystal]
----
require "tablo"

table = Tablo::Table.new([1, 2, 3]) do |t|
  t.add_column("itself", &.itself)
  t.add_column(2, header: "Double") { |n| n * 2 }
  t.add_column(3, header: "Float",
    header_formatter: ->(value : Tablo::CellType) { value.as(String).upcase }) { |n|
    "%.3f" % (n ** 0.5)
  }
end
puts table
----

[literal]
----
+--------------+--------------+--------------+
|       itself |       Double | FLOAT        |
+--------------+--------------+--------------+
|            1 |            2 | 1.000        |
|            2 |            4 | 1.414        |
|            3 |            6 | 1.732        |
+--------------+--------------+--------------+
----

To illustrate the 2nd form, we will use the `Tablo::Util.stretch` method,
which can be useful on groups or headings.

[source,crystal]
----
require "tablo"

table = Tablo::Table.new([1, 2, 3]) do |t|
  t.add_column("itself", &.itself)
  t.add_column(2, header: "Double") { |n| n * 2 }
  t.add_group("Numbers",
    formatter: ->(value : Tablo::CellType, width : Int32) {
      Tablo::Util.stretch(value.as(String), width, ' ') })
  t.add_column(:column_3, header: "String") { |n| n.even?.to_s }
  t.add_group("Text")
end
puts table
----

[Literal]
----
+-----------------------------+--------------+
|  N   u   m   b   e   r   s  |     Text     |
+--------------+--------------+--------------+
|       itself |       Double | String       |
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
|            3 |            6 | false        |
+--------------+--------------+--------------+
----

Form 3 and form 4 apply only on DataCell cell types, as they use the
`cell_data` parameter to conditionnally format the `value`.

Here is an exemple of form 3 with another method from `Tablo::Util`, which use
the `column_index` as formatting condition.

[source,crystal]
----
require "tablo"

table = Tablo::Table.new([0.0, 1.470001, 2.234, 5.78707],
  body_formatter: ->(value : Tablo::CellType, cell_data : Tablo::CellData) {
    case cell_data.column_index
    when 1 then Tablo::Util.dot_align(value.as(Float), 4, Tablo::Util::DotAlign::Empty)
    when 2 then Tablo::Util.dot_align(value.as(Float), 4, Tablo::Util::DotAlign::Blank)
    when 3 then Tablo::Util.dot_align(value.as(Float), 4, Tablo::Util::DotAlign::Dot)
    when 4 then Tablo::Util.dot_align(value.as(Float), 4, Tablo::Util::DotAlign::DotZero)
    else        value.as(Float).to_s
    end
  }) do |t|
  t.add_column("itself", &.itself)
  t.add_column("dot_align\nEmpty", &.itself)
  t.add_column("dot_align\nBlank", &.itself)
  t.add_column("dot_align\nDot", &.itself)
  t.add_column("dot_align\nDotZero", &.itself)
end
puts table
----

[literal]
----
+--------------+--------------+--------------+--------------+--------------+
|       itself |    dot_align |    dot_align |    dot_align |    dot_align |
|              |        Empty |        Blank |          Dot |      DotZero |
+--------------+--------------+--------------+--------------+--------------+
|          0.0 |              |       0      |       0.     |       0.0    |
|     1.470001 |       1.47   |       1.47   |       1.47   |       1.47   |
|        2.234 |       2.234  |       2.234  |       2.234  |       2.234  |
|      5.78707 |       5.7871 |       5.7871 |       5.7871 |       5.7871 |
+--------------+--------------+--------------+--------------+--------------+
----
Incidentally, this last example displays all the formatting possibilities of
the `Tablo::Util.dot_align` method.

Compared to the third form, form 4 also allows the use of the width value. +
Its usefulness seems less obvious, however.

Overview of the 4 different forms of formatter procs:

[cols="1,5"]
|===
| Forms of formatter procs | Parameter and types, in order 

| 1st form | `value` : `Tablo::CellType` +
 used by: `TextCell` or `DataCell` 

| 2nd form | `value` : `Tablo::CellType`, `width` : `Int32` +
 used by: `TextCell` or `DataCell` 

| 3rd form | `value` : `Tablo::CellType`, `cell_data` : `Tablo::CellData` +
 used by: `DataCell` 

| 4th form | `value` : `Tablo::CellType`, `cell_data` : `Tablo::CellData`, 
`width` : `Int32` +
 used by: `DataCell` 

|===


==== Styling

When it comes to terminal styling, the possibilities are limited, especially
as they depend on the terminal's capabilities. There are therefore
2 complementary ways of proceeding:

- play with the mode (underlined, bold, italic...)
- use color

This can be done using ANSI code sequences, or preferably, using the
`colorize` module of the standard library.

In this section, we'll be using color, altered characters and graphic borders
with the Fancy border type. Output will therefore be presented as SVG images, so as
to guarantee perfect rendering, whatever the medium used. 

For styling, there are 5 forms of Procs.

The first uses only (formatted) content as a parameter, and therefore does not
allow conditional styling.

Let's look at a simple example, with yellow borders and blue headers.

[source,crystal]
----
require "tablo"
require "colorize"

table = Tablo::Table.new([1, 2, 3],
  border_type: Tablo::BorderName::Fancy,
  border_styler: ->(border_char : String) {border_char.colorize(:yellow).to_s},
  header_styler: ->(content : String) {content.colorize(:blue).to_s} ) do |t|
  t.add_column("itself", &.itself)
  t.add_column(2, header: "Double") { |n| n * 2 }
  t.add_column(:column_3, header: "String") { |n| n.even?.to_s }
end
puts table
----

image:styling_first_form.svg[width="460",caption="Styling
first form:"]

Cool! Let's do now some conditional styling, painting in bold green all values
greater than 2 in all numeric columns and underlining "true" `String` values in third
column: this is the third form of styling.

Just add, at the table level before `header_styler`, the following lines :
[source,crystal]
----
  body_styler: ->(value : Tablo::CellType, content : String) {
    case value
    when Int32
      value > 2 ? content.colorize.fore(:green).mode(:bold).to_s : content
    else
      value == "true" ? content.colorize.mode(:underline).to_s : content
    end
  },
----

image:styling_third_form.svg[width="460",caption="Styling
third form:"]

Let's end with a final example, with a black-and-white look: how do you
display rows alternately in light gray (with a bit of italics) and dark gray
to make them easier to read?

This would be the 4th form.


[source,crystal]
----
require "tablo"
require "colorize"

table = Tablo::Table.new([1, 2, 3, 4, 5],
  title: Tablo::FramedHeading.new("My black and white fancy table"),
  footer: Tablo::FramedHeading.new("End of data"),
  border_type: Tablo::BorderName::Fancy,
  border_styler: ->(border_char : String) {border_char.colorize(:light_gray).to_s},
  body_styler: ->(value : Tablo::CellType, cell_data : Tablo::CellData, content : String) {
    if cell_data.row_index.even? 
      "\e[3m" + content.colorize(:light_gray).to_s + "\e[0m"  <1>
    else
      content.colorize.fore(:dark_gray).mode(:bold).to_s
    end },
  header_styler: ->(content : String) {content.colorize.mode(:bold).to_s} ) do |t|
  t.add_column("itself", &.itself)
  t.add_column(2, header: "Double") { |n| n * 2 }
  t.add_column(:column_3, header: "String") { |n| n.even?.to_s }
end
puts table
----

<1> From version 1.10 onwards, Crystal does support italic mode, and the use
of ANSI sequences is given here simply as an example.

image:styling_fourth_form.svg[width="460",caption="Styling
fourth form:"]

Overview of the 5 different forms of styler procs:

[cols="1,5"]
|===
| Forms of styler procs | Parameter and types, in order 

| 1st form | `(formatted) content` : `String` +
 used by: `Border`, `TextCell` or `DataCell`

| 2nd form | `(formatted) content` : `String`, `line_index` :  `Int32` +
 used by: `TextCell`

| 3rd form | `value` : `Tablo::CellType`, `(formatted) content` : `String` +
 used by: `DataCell`

| 4th form | `value` : `Tablo::CellType`, `cell_data` : `Tablo::CellData`, 
`(formatted) content` : `String` +
 used by: `DataCell`

| 5th form | `value` : `Tablo::CellType`, `cell_data` : `Tablo::CellData`, 
`(formatted) content` : `String`, `line_index` : `Int32` +
 used by: `DataCell`
|===


=== Packing
In the previous examples, the notion of column width was used. For a better
understanding, the diagram below highlights the structure of a column.
                   
image:column_layout.svg[width="460"]

As we saw at the start of this tutorial, by default, all columns have the same
width, i.e. 12 characters.  

Of course, this value can be modified globally when initializing the table, or
individually when defining columns.  The same applies to left and right
padding, as well as to the padding character (a space, by default). 

The border width is 1 character maximum, but can be 0 (i.e. no border) if the
letter E is used in the border definition string.

The `pack` method ...

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
I AM HERE
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


== Complete API

=== Tablo internals
Table definition is largely based on default values, which can be modified via
named parameters if required.

Most of the parameters defined when initializing a table are taken over by
default, if appropriate, when creating columns.

Tablo features a column-based rather than row-based API, which means
that header and body lines are automatically synchronized. 

At the heart of Tablo's operation lies the cell, a data structure containing
all the elements required for display. There are 2 different types of cell:

- Those containing source or source-dependent data, the DataCell type (for Header and Body rows)
- Text cells, the TextCell type (for Group and Headings)

They differ mainly in 2 exclusive attribute types:

- RowType for TextCell cells

- CellData for DataCell cells

Both have the `value` attribute, which contains the raw data extracted from
source. Its type is `Tablo::CellType`


[literal]
----
+--------------------------------------------+
|              Numbers and text              |
+--------------------------------------------+
 
                  No booleans                 
+--------------+--------------+--------------+
|            1 |            2 | false        |
|            2 |            4 | true         |
+--------------+--------------+--------------+
                  End of page                 
+--------------+--------------+--------------+
|            3 |            6 | false        |
|              |              |              |
+--------------+--------------+--------------+
                  End of page                 
----


////
== Overview


To give you a taste of both the richness of the layout, here's an example that's somewhat contrived, but interesting to study.

image::docs/assets/images/overview.svg[width="400",caption="Figure 8:"]

{empty} +

and the corresponding source code.

[source,crystal]
----
include::docs/assets/sources/overview.cr[]
----

////
